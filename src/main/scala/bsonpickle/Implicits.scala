package bsonpickle

import scala.reflect.ClassTag
import scala.concurrent.duration.{ Duration, FiniteDuration }
import scala.language.higherKinds
import scala.language.experimental.macros
import java.util.UUID
import java.util.Date
import java.time.Instant

import reactivemongo.bson._

/**
  * Typeclasses to allow read/writing of all the common
  * data-types and data-structures in the standard library
  */
trait Implicits extends Types with BigDecimalSupport {
  imp: Generated =>

  import Aliases._

  // We need these guys, but they'd be generated by the `Generated`
  // code, which is mixed in together with this fellow
  implicit def Tuple2R[T1: R, T2: R]: R[(T1, T2)]
  implicit def Tuple2W[T1: W, T2: W]: W[(T1, T2)]


  implicit class MergeRW[T: ClassTag](a: ReadWriter[T]){
    def merge[V <: R: ClassTag, R >: T](b: ReadWriter[V]): ReadWriter[R] = {
      ReadWriter[R](
        {
          case r: V => b.write(r)
          case r: T => a.write(r)
        },
        b.read.orElse[BSONValue, R](a.read)
      )
    }
  }
  implicit class MergeR[T: ClassTag](a: Reader[T]){
    def merge[V <: R: ClassTag, R >: T](b: Reader[V]): Reader[R] = {
      Reader[R](b.read.orElse[BSONValue, R](a.read))
    }
  }

  implicit class MergeW[T: ClassTag](a: Writer[T]){
    def merge[V <: R: ClassTag, R >: T](b: Writer[V]): Writer[R] = {
      Writer[R]{
        case r: V => b.write(r)
        case r: T => a.write(r)
      }

    }
  }

  /**
    * APIs that need to be exposed to the outside world to support Macros
    * which depend on them, but probably should not get used directly.
    */
  object Internal {
    type Reader[T] = Implicits.this.Reader[T]
    type Writer[T] = Implicits.this.Writer[T]
    def makeReader[T](pf: PartialFunction[BSONValue, T]) = imp.Reader(pf)
    def makeWriter[T](f: T => BSONValue) = imp.Writer(f)
    // Have to manually spell out the implicit here otherwise compiler crashes
    def read[T](expr: BSONValue)(implicit ev: Reader[T]): T = imp.read(expr)(ev)
    def write[T](expr: T)(implicit ev: Writer[T]): BSONValue = imp.write(expr)(ev)

    def merge0[T: ClassTag, R, U](f: T => R): U => R = {
      case t: T => f(t)
    }

    def merge[T: ClassTag, R, V: ClassTag, U](f: T => R, g: V => R): U => R = {
      case v: V => g(v)
      case t: T => f(t)
    }



    def validate[T](name: String)(pf: PartialFunction[BSONValue, T]) = new PartialFunction[BSONValue, T] {
      def isDefinedAt(x: BSONValue) = pf.isDefinedAt(x)

      def apply(v1: BSONValue): T = pf.applyOrElse(v1, (x: BSONValue) => throw Invalid.Data(x, name))
      override def toString = s"validate($name, $pf)"
    }
    def validateReader[T](name: String)(r: => Reader[T]): Reader[T] = new Reader[T]{
      override val read0 = validate(name)(r.read)
      override def toString = s"validateReader($name, $r)"
    }
    def validateReaderWithWriter[T](name: String)(r: => Reader[T], w: => Writer[T]) = new Reader[T] with Writer[T] {
      override def read0 = validate(name)(r.read)
      override def write0 = w.write
      override def toString = s"validateReaderWithWriter($name, $r, $w)"
    }
  }

  import Internal._

  def Case0R[T](t: () => T) = R[T]({ case x => t() })
  def Case0W[T](f: T => Boolean) = W[T](x => BSONDocument.empty)
  def SingletonR[T](t: T) = R[T]({ case x => t })
  def SingletonW[T](f: T) = W[T](x => BSONDocument.empty)

  private[this] type JPF[T] = PartialFunction[BSONValue, T]
  private[this] val booleanReaderFunc: JPF[Boolean] = Internal.validate("Boolean") {
    case BSONBoolean(true) => true
    case BSONBoolean(false) => false
  }
  implicit val BooleanRW = RW[Boolean](
    BSONBoolean(_),
    booleanReaderFunc
  )
  implicit val UnitRW = RW[Unit](
    _ => BSONDocument.empty, { case _ => () }
  )

  def CaseR[T: R, V](f: T => V, names: Array[String], defaults: Array[BSONValue]): Reader[V] = {
    Reader {
      case bson: BSONDocument => f(implicitly[R[T]].read(this.mapToArray(bson, names, defaults)))
    }
  }
  def CaseW[T: W, V](f: V => Option[T], names: Array[String], defaults: Array[BSONValue]): Writer[V] = {
    Writer {
      t: V =>
        this.arrayToMap(implicitly[W[T]].write(f(t).get).asInstanceOf[BSONArray], names, defaults)
    }
  }

  private[this] def numericStringReaderFunc[T](func: String => T): JPF[T] = Internal.validate("String") {
    case x: BSONString => func(x.value)
  }
  private[this] def NumericStringReadWriter[T](func: String => T) = RW[T](
    x => BSONString(x.toString),
    numericStringReaderFunc[T](func)
  )
  private[this] def numericReaderFunc[T: Numeric](func: Double => T, func2: String => T): JPF[T] = Internal.validate("Number or String") {
    case n @ BSONDouble(x) => try { func(x) } catch { case e: NumberFormatException => throw Invalid.Data(n, "Number") }
    case s @ BSONString(x) => try { func2(x) } catch { case e: NumberFormatException => throw Invalid.Data(s, "Number") }
  }

  private[this] def doubleReadWriter[T: Numeric](func: Double => T, func2: String => T): RW[T] = RW[T](
    {
      case x @ Double.PositiveInfinity => BSONDouble(Double.PositiveInfinity)
      case x @ Double.NegativeInfinity => BSONDouble(Double.NegativeInfinity)
      case x: Double if java.lang.Double.isNaN(x) => BSONDouble(x)
      case x: Float if java.lang.Double.isNaN(x) => BSONDouble(x)
      case x => BSONDouble(implicitly[Numeric[T]].toDouble(x))
    },
    numericReaderFunc[T](func, func2)
  )
  private[this] val stringReaderFunc: JPF[String] = Internal.validate("String") {
    case x: BSONString => x.value
  }
  implicit val StringRW = RW[String](BSONString, stringReaderFunc)

  private[this] val symbolReaderFunc: JPF[Symbol] = Internal.validate("Symbol") {
    case x: BSONString => Symbol(x.value)
  }
  implicit val SymbolRW = RW[Symbol](
    x => BSONString(x.toString().substring(1)),
    symbolReaderFunc
  )

  implicit val CharRW = NumericStringReadWriter[Char](_ (0))
  implicit val IntRW = RW[Int](
    { case value => BSONInteger(value) }, //
    { case BSONInteger(value) => value }
  )
  implicit val ByteRW = readerWriterVia[Byte, Int](_.toByte, _.toInt)
  implicit val ShortRW = readerWriterVia[Short, Int](_.toShort, _.toInt)
  implicit val LongRW = RW[Long](
    { case value => BSONLong(value) }, //
    { case BSONLong(value) => value }
  )
  implicit val FloatRW = doubleReadWriter(_.toFloat, _.toFloat)
  implicit val DoubleRW = doubleReadWriter(identity, _.toDouble)
  implicit val BigIntRW = NumericStringReadWriter[BigInt](BigInt(_))
  implicit val BigDecimalRW = NumericStringReadWriter[BigDecimal](exactBigDecimal)

  import collection.generic.CanBuildFrom

  implicit def SeqishR[V[_], T: R]
  (implicit cbf: CanBuildFrom[Nothing, T, V[T]]): R[V[T]] = R[V[T]](
    Internal.validate("Array(n)") { case x: BSONArray => x.stream.flatMap(_.toOption.map(read[T])).to[V] }
  )

  implicit def SeqishW[T: W, V[_] <: Iterable[_]]: W[V[T]] = W[V[T]] {
    (x: V[T]) => BSONArray(x.iterator.asInstanceOf[Iterator[T]].map(write(_)).toArray)
  }

  private[this] def SeqLikeW[T: W, V[_]](g: V[T] => Option[Seq[T]]): W[V[T]] = W[V[T]](
    x => BSONArray(g(x).get.map(x => write(x)))
  )
  private[this] def SeqLikeR[T: R, V[_]](f: Seq[T] => V[T]): R[V[T]] = R[V[T]](
    Internal.validate("Array(n)") { case x: BSONArray => f(x.stream.flatMap(_.toOption.map(read[T]))) }
  )

  implicit def OptionW[T: W]: W[Option[T]] = SeqLikeW[T, Option](x => Some(x.toSeq))
  implicit def SomeW[T: W] = W[Some[T]](OptionW[T].write)
  implicit def NoneW: W[None.type] = W[None.type](OptionW[Int].write)
  implicit def OptionR[T: R]: R[Option[T]] = SeqLikeR[T, Option](_.headOption)
  implicit def SomeR[T: R] = R[Some[T]](OptionR[T].read andThen (_.asInstanceOf[Some[T]]))
  implicit def NoneR: R[None.type] = R[None.type](OptionR[Int].read andThen (_.asInstanceOf[None.type]))

  implicit def ArrayW[T: W] = SeqLikeW[T, Array](Array.unapplySeq)
  implicit def ArrayR[T: R : ClassTag] = SeqLikeR[T, Array](x => Array.apply(x: _*))

  implicit def MapW[K: W, V: W]: W[Map[K, V]] =
    if (implicitly[W[K]] == implicitly[W[String]])
      W[Map[K, V]](x => BSONDocument(x.toSeq.map { case (k, v) => BSONElement(k.asInstanceOf[String], write[V](v)) }))
    else
      W[Map[K, V]](x => BSONArray(x.toSeq.map(write[(K, V)])))


  implicit def MapR[K: R, V: R]: R[Map[K, V]] =
    if (implicitly[R[K]] == implicitly[R[String]])
      R[Map[K, V]](Internal.validate("Object") {
        case x: BSONDocument => x.stream.flatMap(_.toOption.map { case BSONElement(k, v) => (k.asInstanceOf[K], read[V](v)) }).toMap
      })
    else
      R[Map[K, V]](Internal.validate("Array(n)") {
        case x: BSONArray => x.stream.flatMap(_.toOption.map(read[(K, V)])).toMap
      })

  implicit def EitherR[A: R, B: R]: R[Either[A, B]] = R[Either[A, B]](
    RightR[A, B].read orElse LeftR[A, B].read
  )
  implicit def RightR[A, B: R]: R[Right[A, B]] = R[Right[A, B]] {
    case BSONArraySuccess(BSONBoolean(true), value) => Right(read[B](value))
  }
  implicit def LeftR[A: R, B]: R[Left[A, B]] = R[Left[A, B]] {
	case BSONArraySuccess(BSONBoolean(false), value) => Left(read[A](value))
  }

  implicit def RightW[A, B: W]: W[Right[A, B]] = {
	implicit val wA: W[A] = null
	W[Right[A, B]](EitherW[A, B].write)
  }

  implicit def LeftW[A: W, B]: W[Left[A, B]] = {
    implicit val wB: W[B] = null
	W[Left[A, B]](EitherW[A, B].write)
  }

  implicit def EitherW[A: W, B: W]: W[Either[A, B]] = W[Either[A, B]] {
    case Left(t) => BSONArray(BSONBoolean(false), write(t))
    case Right(t) => BSONArray(BSONBoolean(true), write(t))
  }
  implicit val DurationW: W[Duration] = W[Duration] {
    case Duration.Inf => write("inf")
    case Duration.MinusInf => write("-inf")
    case x if x eq Duration.Undefined => write("undef")
    case x => write(x.toNanos)
  }

  implicit val InfiniteW = W[Duration.Infinite](DurationW.write)
  implicit val InfiniteR = R[Duration.Infinite] {
    Internal.validate("DurationString") {
      case BSONString("inf") => Duration.Inf
      case BSONString("-inf") => Duration.MinusInf
      case BSONString("undef") => Duration.Undefined
    }
  }

  implicit val FiniteW = W[FiniteDuration](DurationW.write)
  implicit val FiniteR = R[FiniteDuration] {
    Internal.validate("DurationString") {
      case x: BSONString => Duration.fromNanos(x.value.toLong)
    }
  }

  implicit val DurationR = R[Duration](Internal.validate("DurationString") {
    FiniteR.read orElse InfiniteR.read
  })

  implicit def UuidR: R[UUID] = R[UUID] { case BSONString(s) => UUID.fromString(s) }
  implicit def UuidW: W[UUID] = W[UUID] { case t: UUID => BSONString(t.toString) }

  implicit def DateR: R[Date] = R[Date] {
	Internal.validate("DateTime") {
      case x: BSONDateTime => new Date(x.value)
      case x: BSONLong => new Date(x.value)
      case x: BSONString => new Date(x.value.toLong)
    }
  }
  implicit def DateW: W[Date] = W[Date] {
    case d => BSONDateTime(d.getTime)	
  }

  implicit def InstantR: R[Instant] = R[Instant] {
	Internal.validate("InstantDateTime") {
      case x: BSONDateTime => java.time.Instant.ofEpochMilli(x.value)
      case x: BSONLong => java.time.Instant.ofEpochMilli(x.value)
      case x: BSONString => java.time.Instant.ofEpochMilli(x.value.toLong)
    }
  }
  implicit def InstantW: W[Instant] = W[Instant] {
    case instant => BSONDateTime(instant.getEpochSecond * 1000 + instant.getNano / 1000000)	
  }

  implicit def ByteArrayR: R[Array[Byte]] = R[Array[Byte]] {
    Internal.validate("Array[Byte]") {
	  case bin: BSONBinary => bin.byteArray
	}
  }
  implicit def ByteArrayW: W[Array[Byte]] = W[Array[Byte]] {
    case bin => BSONBinary(bin, Subtype.GenericBinarySubtype)
  }

  def makeReader[T](pf: PartialFunction[BSONValue, T]) = Reader.apply(pf)
  def makeWriter[T](f: T => BSONValue): Writer[T] = Writer.apply(f)

}
